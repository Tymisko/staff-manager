1. if (!(_dismissalDate == null)) if (!(dgvDiary.SelectedRows.Count == 0))  - nie razi Ci w oczy ten nadmiarowy nawias z negacj? Dlaczego nie zrobisz po prostu != (bd藕 is not w przypadku nulla)? Ewentualnie am gdzie si da to odwr贸ci ifa albo zrobi tr贸jargumentowy, wszystkie opcje wygldaj lepiej ni偶 ten nawias wedug mnie 
2. GetSelectedEmployeeId() -> rzuca exception tylko po to, by poziom wy偶ej go zapa i wywietli MessageBoxa, nie powiniene u偶ywa exception贸w tam, gdzie wystarcz if'y 
3. Trzymanie danych w pliku wymusza u Ciebie (de)serializacj w wielu miejscach, lepiej by to byo trzyma w pamici i robi zrzut przy zmianach i ewentualnie pomin odczytywanie po zapisie (zapis wywali exceptiona jeli si nie powiedzie, a jeli si uda to nie bdzie rozjazdu).
var selectedEmployee = employees.FirstOrDefault(e => e.Id == id) as Employee; tbId.Text = selectedEmployee!.Id.ToString();
Z czego wynika ten wykrzyknik? Jedna metoda deserializuje plik, wyciga dane, przepycha dalej samo id by inna metoda znowu zdeserializowaa ten sam plik i wycigna wpis po id. Mo偶e gdyby na r贸偶nych etapach wyciga dane z r贸偶nych plik贸w/tabel to przepychanie samego id ma sens, ale jeli masz dane w rku to po co sobie utrudnia?
Je偶eli zabezpieczasz si przed modyfikacj pliku z innego 藕r贸da w trakcie dziaania programu to si chyba nie udao
4. Nazwa "Main" dla okna do mnie nie przemawia (jednak nazwa kojarzy si z czym innym).
5. public string? Comments { get; } niby oznaczye jako nullable ale domylnie ustawiasz na "" - tutaj musisz si na co zdecydowa.
6. FileHelper te偶 ma jaki problem z podejmowaniem decyzji, raz korzysta ze cie偶ki z publicznego statica, raz z tego co dosta w konstruktorze (co p贸ki co jest tym samym).
7. Osobicie nie lubi var'贸w - ale tam gdzie wprost wida co jaki ma typ jeszcze je znios, u Ciebie s wszdzie co obni偶a czytelno, np tutaj var employees = _fileHelper.DeserializeFromJson(); 
8. Bya mowa o modyfikowaniu pliku z zewntrz to i warto wspomnie o kwestii dostpu do pliku, odczyt/zapis mo偶e si wysypa, co Twoja aplikacja zrobi wtedy? 
9. _fileHelper = new FileHelper<List<Employee>>(Program.StaffDiaryPath); ka偶da kontrolka sobie sama to powouje, zamiast tego powiniene to potraktowa jako "serwis", stworzy raz i przekaza wszdzie gdzie potrzebne (winformsowemu designerowi chyba nie przeszkadzao jak co wlatuje do konstruktora), przy okazji zdejmujesz z kontrolki odpowiedzialno za operacje na pliku (bo tego raczej nie powinna robi :P).
Wtedy mo偶esz w atwy spos贸b podmieni serwis z tego wykorzystujcego lokalny plik na co, co np. czy si z chmur, bez potrzeby zmieniania tego w n miejscach (pogooglaj repository pattern, dependency injection - mocne sowa jak na desktop, ale chodzi o sam ide).
10. No i og贸lnie desktopy s passe (przegldarka mocno ogranicza wiec dalej maj sens, wic jak ju偶 to jakie kombajniaste apki potrzebujce mn贸stwa zasob贸w czy jakie serwisy dziaajce w tle).
11. A co do "uczenia si" winforms贸w - one s prymitywne jak tylko mog, tu nie ma zbytnio czego (i po co) si uczy.

Pola z podkreleniem powiniene poprzedza thisem - this._pole

add to .gitignore 
- AddEditEmployee.cs.bak